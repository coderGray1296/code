## 背包问题总结

#### 0-1背包问题
首先简单描述下问题，给你一个可装载重量为W的背包和N个物品，每个物品有重量和价值两个属性。其中第i个物品的重量为wt[i]，价值为val[i]，现在让你用这个背包装物品，最多能装的价值是多少？

举个简单的例子如下：

```
N = 3, W = 4
wt = [2, 1, 3]
val = [4, 2, 3]
```
结果返回 6 ，选择前两件物品装进背包，总重量 3 小于W，可以获得最大价值 6。

题目就是这么简单，一个典型的动态规划问题。**这个题目中的物品不可以分割，要么装进包里，要么不装，不能说切成两块装一半**。这也许就是 0-1 背包这个名词的来历。

下面开始进行动态规划的标准步骤：
1. 首先明确状态和选择。 先说**状态**，如何才能描述一个问题局面？只要给定几个可选物品和一个背包的容量限制，就形成了一个背包问题，对不对？所以状态有两个，就是「背包的容量」和「可选择的物品」。再说**选择**，也很容易想到啊，对于每件物品，你能选择什么？选择就是「装进背包」或者「不装进背包」嘛。明白了状态和选择，动态规划问题基本上就解决了，只要往这个框架套就完事儿了：
```
for 状态1 in 状态1的所有取值：
    for 状态2 in 状态2的所有取值：
        for ...
            dp[状态1][状态2][...] = 择优(选择1，选择2...)
```
2. 第二步要明确dp数组的定义。dp数组是什么？其实就是描述问题局面的一个数组。换句话说，我们刚才明确问题有什么「状态」，现在需要用dp数组把状态表示出来。首先看看刚才找到的「状态」，有两个，也就是说我们需要一个二维dp数组，一维表示可选择的物品，一维表示背包的容量。**dp[i][w]的定义如下：对于前i个物品，当前背包的容量为w，这种情况下可以装的最大价值是dp[i][w]** 比如说，如果 dp[3][5] = 6，其含义为：对于给定的一系列物品中，若只对前 3 个物品进行选择，当背包容量为 5 时，最多可以装下的价值为 6。根据这个定义，我们想求的最终答案就是dp[N][W]。base case 就是dp[0][..] = dp[..][0] = 0，因为没有物品或者背包没有空间的时候，能装的最大价值就是 0。
3. 第三步根据选择，进行状态的转移。dp[i][w]表示：对于前i个物品，当前背包的容量为w时，这种情况下可以装下的最大价值是dp[i][w]。**如果你没有把这第i个物品装入背包，那么很显然，最大价值dp[i][w]应该等于dp[i-1][w]**。你不装嘛，那就继承之前的结果。**如果你把这第i个物品装入了背包，那么dp[i][w]应该等于dp[i-1][w-wt[i-1]] + val[i-1]** 你应该寻求剩余重量w-wt[i-1]限制下能装的最大价值，加上第i个物品的价值val[i-1]，这就是装第i个物品的前提下，背包可以装的最大价值。
4. 最后一步，上代码
```
def package(N, W, wt, val):
    dp = [[0 for _ in range(W+1)] for _ in range(N+1)]
    for i in range(1, N+1):
        for j in range(1, M+1):
            if j - wt[i-1] < 0:
                #当当前背包容量装不下，只能选择不装
                dp[i][j] = dp[i-1][j]
            else:
                dp[i][j] = max(dp[i-1][j], dp[i-1][j-wt[i-1]] + val[i-1])
    return dp[-1][-1]
```
从上面的代码中可以看出，下一轮的迭代情况只和上一轮的状态有关，dp[i][j] 都是通过上一行 dp[i-1][..] 转移过来的，之前的数据都不会再使用了。那么我们能否进行状态压缩呢。
```
def package(N, W, wt, val):
    dp = [0 for _ in range(W+1)]
    for i in range(1, N+1):
        #这里要逆序逆序weight
        for j in range(N, 0, -1):
            if j - wt[i-1] < 0:
                dp[j] = dp[j]
            else:
                dp[j] = max(dp[j], dp[j-wt[i-1]]+val[i-1])
    return dp[-1]
```
**其中逆序遍历weight保证的是，不让状态受之前影响，因为是无重复选择，否则当前一轮状态更新，后面的状态会受前面已更新的影响，而不是完全由上一轮决定** index为j-wt[i-1]肯定在j之前，因为递推是当前轮次，前面状态去推后面，因此压缩之后，从后往前更新的方式，能够保留前面（上一轮）的状态。**后面会跟完全背包问题进行对比**

e.g.leetcode416 分割等和子集：给定一个只包含正整数的非空数组。是否可以将这个数组分割成两个子集，使得两个子集的元素和相等。
```
输入: [1, 5, 11, 5]

输出: true

解释: 数组可以分割成 [1, 5, 5] 和 [11].
```
这个问题可以转化为背包大小为sum/2的0-1背包问题，状态的值并非val了，而是true false。

给一个可装载重量为 sum / 2 的背包和 N 个物品，每个物品的重量为 nums[i]。现在让你装物品，是否存在一种装法，能够恰好将背包装满？

```
def canPartition(self, nums):
        """
        :type nums: List[int]
        :rtype: bool
        """
        if len(nums) == 1:
            return False
        sum_val = sum(nums)
        if sum_val % 2 != 0:
            return False
        sum_val = sum_val // 2
        dp = [False for _ in range(sum_val + 1)]
        dp[0] = True
        for i in range(1, len(nums)+1):
            #需要逆序遍历，否则当前一轮状态更新，后面的状态会受前面已更新的影响，而不是完全由上一轮决定
            for j in range(sum_val, 0, -1):
                if j - nums[i-1] < 0:
                    dp[j] = dp[j]
                else:
                    dp[j] = dp[j] or dp[j - nums[i-1]]
        return dp[-1]
```

#### 完全背包问题
完全背包问题和0-1背包的区别就是：0-1背包的物品只能选择0或者1，不能重复，而完全背包每个物品可以任意多次选择，下面用一个例题来解释完全背包问题。

leetcode518 Coin Change 2

给定不同面额的硬币和一个总金额。写出函数来计算可以凑成总金额的硬币组合数。假设每一种面额的硬币有无限个。
```
输入: amount = 5, coins = [1, 2, 5]
输出: 4
解释: 有四种方式可以凑成总金额:
5=5
5=2+2+1
5=2+1+1+1
5=1+1+1+1+1
```
**第一想法想到了和爬楼梯类似的递推方法，但是仔细一想并不对，爬楼梯的思想中，状态的转移考虑了不同状态的组合和排序，是有序的，比如先上 2 在上1 再上2 和 2 2 1是两种情况，而本题只考虑组合，因此用完全背包解答**

我们可以把这个问题转化为背包问题的描述形式：

有一个背包，最大容量为 amount，有一系列物品 coins，每个物品的重量为 coins[i]，每个物品的数量无限。请问有多少种方法，能够把背包恰好装满？

同样，按照dp的正常逻辑来：
1. 明确状态和选择 状态有两个，就是「背包的容量」和「可选择的物品」，选择就是「装进背包」或者「不装进背包」嘛，背包问题的套路都是这样。
```
for 状态1 in 状态1的所有取值：
    for 状态2 in 状态2的所有取值：
        for ...
            dp[状态1][状态2][...] = 计算(选择1，选择2...)
```
2. 明确 dp 数组的定义

dp[i][j] 的定义如下：若只使用前 i 个物品，当背包容量为 j 时，有 dp[i][j] 种方法可以装满背包。换句话说，**若只使用 coins 中的前 i 个硬币的面值，若想凑出金额 j，有 dp[i][j] 种凑法**。base case 为 dp[0][..] = 0， dp[..][0] = 1。因为如果不使用任何硬币面值，就无法凑出任何金额；如果凑出的目标金额为 0，那么“无为而治”就是唯一的一种凑法。

3. 状态的转移

**我们这个问题的特殊点在于物品的数量是无限的，所以这里和之前写的背包问题文章有所不同**。**如果你不把这第 i 个物品装入背包**，也就是说你不使用 coins[i] 这个面值的硬币，那么凑出面额 j 的方法数 dp[i][j] 应该等于 dp[i-1][j]，继承之前的结果。**如果你把这第 i 个物品装入了背包，也就是说你使用 coins[i] 这个面值的硬币**，那么 dp[i][j] 应该等于 dp[i][j-coins[i-1]] **综上就是两种选择，而我们想求的 dp[i][j] 是「共有多少种凑法」，所以 dp[i][j] 的值应该是以上两种选择的结果之和**。这里的不同点就是如果选择了不是从i-1轮推到这里，因为可以重复，有可能在这个状态中，i物品已经在背包中了，**所以这里和0-1背包不同，也导致了压缩状态时，不需要从后逆序遍历，因为不用保证只使用一次**
4. 上代码
```
int change(int amount, int[] coins) {
    int n = coins.length;
    int[][] dp = amount int[n + 1][amount + 1];
    // base case
    for (int i = 0; i <= n; i++)
        dp[i][0] = 1;

    for (int i = 1; i <= n; i++) {
        for (int j = 1; j <= amount; j++)
            if (j - coins[i-1] >= 0)
                dp[i][j] = dp[i - 1][j]
                         + dp[i][j - coins[i-1]];
            else
                dp[i][j] = dp[i - 1][j];
    }
    return dp[n][amount];
}
```
考虑状态压缩
```
int change(int amount, int[] coins) {
    int n = coins.length;
    int[] dp = new int[amount + 1];
    dp[0] = 1; // base case
    for (int i = 0; i < n; i++)
        for (int j = 1; j <= amount; j++)
            if (j - coins[i] >= 0)
                dp[j] = dp[j] + dp[j-coins[i]];
    return dp[amount];
}
```

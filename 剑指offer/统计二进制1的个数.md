# 统计二进制1的个数
输入一个整数，输出该数二进制表示中1的个数。其中负数用补码表示。

首先看到是二进制的问题，想到了统计1的个数，可以在循环里面累加，但是看到存在负数的情况，因此不能简单的进行累加，而要存在一个位长和计算机一样的32位数组中，因此补码涉及到反码+1。因此按照如下逻辑写了代码
```
        def NumberOf1(self, n):
        if n == 0:
            return 0
        bit = [0] * 31
        number = abs(n)
        while number > 0:
            temp = 1
            count = -1
            while temp <= number:
                temp = temp * 2
                count += 1
            number = number - (temp / 2)
            print(count)
            bit[count] = 1
        if n > 0 :
            return bit.count(1)
        if n < 0:
            for i in range(len(bit)):
                if bit[i] == 1:
                    bit[i] = 0
                    break
                else:
                    bit[i] = 1
            return bit.count(0) + 1
```
上段代码的逻辑完全就是按照之前说的进行的，只不过减少了一层循环，就是在计算补码时，没有转为反码，而是在加一的时候把原码的1当成反码的0，原码的0当成反码的1进行操作。**补码计算就是在反码中找到第一个0将其改变就好，如果是1的话就置0后往后循环，也就是进位的逻辑。**然后提交了上去，发现又一个case没有通过，当n是-2147483648时，我就打印了信息发现是**第19行bit[count]=1**的时候溢出了，我打印了一下发现count是31，由于我投机取巧将初始长度定为31，在最后一行加上1，如果count是31的话，说明值是2^31，而不是2^31-1预期的值，我马上反应过来不对，因为补码有说法：
```
由于有符号为的原码表示时，对于0表示为00...00，但是-0为100...00没有必要，因此将-0的原码给了-2^31，正好是-2147483648，因此这种情况1不是符号位，就是二进制值的位。同时这个数在32位中没有原码，是补码。
```
然后我就进行了两点改变：
- 数组大小变为32:bit = [0] * 32
- 最后一行的1也不用加了，歪打正着我统计的是0的个数，而数组初始就是0，因此不影响结果。
最后是AC了，不过仔细想想还是有点投机取巧的意思，又去找了大神的代码：
```
public int NumberOf1(int n) {
        int count = 0;
        while(n!= 0){
            count++;
            n = n & (n - 1);
         }
        return count;
    }
```
这段小小的代码很是巧妙，运用了位与&运算符，**运算符规定只有对应位置上全是1才是1，否则都是0**，例如：
```
a = 0011 1100
b = 0000 1101
a & b = 0000 1100
```
分析如下：
如果一个整数不为0，那么这个整数至少有一位是1。如果我们把这个整数减1，那么原来处在整数最右边的1就会变为0，原来在1后面的所有的0都会变成1(如果最右边的1后面还有0的话)。其余所有位将不会受到影响。

举个例子：一个二进制数1100，从右边数起第三位是处于最右边的一个1。减去1后，第三位变成0，它后面的两位0变成了1，而前面的1保持不变，因此得到的结果是1011.我们发现减1的结果是把最右边的一个1开始的所有位都取反了。这个时候如果我们再把原来的整数和减去1之后的结果做与运算，从原来整数最右边一个1那一位开始所有位都会变成0。如1100&1011=1000.也就是说，把一个整数减去1，再和原整数做与运算，会把该整数最右边一个1变成0.那么一个整数的二进制有多少个1，就可以进行多少次这样的操作。
简直巧妙，但是我看完还有一个疑问，**负数怎么办？况且还有一个特殊情况-2^31，这能cover吗？**
仔细思考过后，发现负数也能cover。负数也是用二进制表示的，只不过使用补码，最高位的符号位是1，用补码减1时，运算规则和正数用原码是一样的。例如最特殊的-2^32，补码是[1000...0000]和代码的目的一样，找有多少个1就进行几次记数和操作。

## 总结：
表扬一下自己，没有AC了就不管了，要进一步深挖。
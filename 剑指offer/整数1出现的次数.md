# 整数1出现的次数
求出1-13的整数中1出现的次数,并算出100-1300的整数中1出现的次数？为此他特别数了一下1-13中包含1的数字有1、10、11、12、13因此共出现6次,但是对于后面问题他就没辙了。ACMer希望你们帮帮他,并把问题更加普遍化,可以很快的求出任意非负整数区间中1出现的次数（从1 到 n 中1出现的次数）。
## 例子：
```
输入: 10
输出: 2
```
这道题的解题思想是：分不同位置1，然后计算其他位的所有可能取值的个数，不断累加。
代码如下：
```
# -*- coding:utf-8 -*-
class Solution:
    def NumberOf1Between1AndN_Solution(self, n):
        result = 0
        m = 1
        while m <= n:
            a = n // m
            b = n % m
            if a % 10 == 0:
                result += (a // 10) * m
            elif a % 10 == 1:
                result += (a // 10) * m + b + 1
            else:
                result += (a // 10 + 1) * m
            m *= 10
        return result
```
案例分析：
**当n=3141592时：** 分别用a和b获取当前置为1的位之前的值和之后的值
| m | a | b |
| ---- | ---- | ---- |
| 1 | 3141592 | 0 |
| 10 | 314159 | 2 |
| 100 | 31415 | 92 |
| 1000 | 3141 | 592 |
思想如下：分三种情况
- 当当前位的值 >= 2时，当这个位置为1的时候，a//10也就是当前位之前的所有位的值都能取到，从0-a//10。同时后面的有m个取值（如m=10，那后缀能取到0-9，10个数；m=1000，那后缀能取到0-999，1000个数），因此累加 **(a // 10 + 1) * m**
- 当当前位的值 = 1的时候，前缀只能取到a//10-1，因为如果这样取了，在*m的时候就会溢出。如n=212,当第二位置1时，前缀只能取0和1没有2，因为m此时为10，考虑的是后缀的所有情况然后后缀=2，例如不能取到大于等于213的所有数，所以这部分是 **(a // 10) * m** 当前缀取2时，后缀只能取等于b的所有值也就是 **b + 1**。
- 当前位值 = 0的时候，同样前缀只能取到a//10-1，因为假设当前位为1的时候已经大于原值0了，只能取小于前缀值的所有数，因此是 **(a // 10) * m**

我在像这种想法时，在考虑这样是否会重复。**如n=3344，当十位置1进行考虑的话会把3114算进来，但是当第三位也就是百位置1时，也会将3114算进来，这不就重复了吗。** 其实想法进入了一个误区，我们不是在算有多少个数，是在算有多少个1，3114本来就有两个1，计数两次恰恰是正确的。
## 总结：
学会将问题进行转化，从整体宏观看问题思考问题，不要想的太微观太具体。
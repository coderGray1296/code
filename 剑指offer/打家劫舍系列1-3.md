# leetcode打家劫舍系列1-3

##打家劫舍I
你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。
给定一个代表每个房屋存放金额的非负整数数组，计算你在不触动警报装置的情况下，能够偷窃到的最高金额。
#### 例子1：
```
输入: [1,2,3,1]
输出: 4
解释: 偷窃 1 号房屋 (金额 = 1) ，然后偷窃 3 号房屋 (金额 = 3)。
偷窃到的最高金额 = 1 + 3 = 4 。
```

#### 例子2：
```
输入: [2,7,9,3,1]
输出: 12
解释: 偷窃 1 号房屋 (金额 = 2), 偷窃 3 号房屋 (金额 = 9)，接着偷窃 5 号房屋 (金额 = 1)。
偷窃到的最高金额 = 2 + 9 + 1 = 12 。
```
这是一道比较典型的动态规划DP寻找最优解的问题。DP问题的关键就是找到状态转移方程，下面我们从简单到复杂，把问题进行拆分进行分析，摸索状态方程：
```
1、当只有1间房的时候，我们没有选择，只能选择抢劫这间房；

2、当有两间房的时候，我们可以比较哪间房里面的钱多，抢劫钱多的房间就好了；

3、当有三间房的时候，有两种方案，抢1，3号房间/抢2号房间的，比较一下哪种方案多；

4、当有四间房的时候，因为我们已经知道了1，2，3间房时能获取到的最大金额，所以我们只需要将抢第四间房的金额数加上抢第二间房能获取到的最大金额数来和第三间房进行比较，取最大值就好了。
由此可以推出状态转移方程
```
**当我们抢劫第i家房间的时候，我们只需要将当前房间的金额于第i-2家房间所能获得的最大金额相加，然后在于第i-1家房间所能获得的最大金额进行比较，取最大的就好**
也就是：
```
用一个result列表来维护i个房间的i个状态，表示当前房间所能获得最大的金额
result[i] = max(result[i-2] + input[i], result[i-1])
只需要这样进行迭代，然后返回result数组的最后一个值就好。
```
为了降低空间复杂度，我们由于我们只需要result[i-1]和result[i-2]来计算，因此只维护两个变量first和second分别代表result[i-2]和result[i-1]。代码如下：
```
def rob(self, l):
    if len(l) == 0:
        return 0
    if len(l) == 1:
        return l[0]
    first = l[0]
    second = max(l[0], l[1])
    for i in range(2, len(l)):
        temp = first + l[i]
        first = second
        if temp > second:
            second = temp
    return second
```
##打家劫舍II
你是一个专业的小偷，计划偷窃沿街的房屋，每间房内都藏有一定的现金。这个地方所有的房屋都围成一圈，这意味着第一个房屋和最后一个房屋是紧挨着的。同时，相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。

给定一个代表每个房屋存放金额的非负整数数组，计算你在不触动警报装置的情况下，能够偷窃到的最高金额。

####例子1:
```
输入: [2,3,2]
输出: 3
解释: 你不能先偷窃 1 号房屋（金额 = 2），然后偷窃 3 号房屋（金额 = 2）, 因为他们是相邻的。
```
####例子2:
```
输入: [1,2,3,1]
输出: 4
解释: 你可以先偷窃 1 号房屋（金额 = 1），然后偷窃 3 号房屋（金额 = 3）。
     偷窃到的最高金额 = 1 + 3 = 4 。
```
这个相比第一个问题多了一个条件，就是是一个圆形区域，首尾是相连的，也就是说**不能从头到尾维护最优状态，然后输出最后一个房屋的最优状态**而是要进行分类考虑。我是这样考虑的：
```
共有两种情况：
1.第一个房屋必取，所以维护最优状态数组的初始化就是[nums[0],nums[0]]，由于第一个取了，所以我们最后一个就不能取，所以输出倒数第二间房屋的最优状态也就是res[-2]，中间转移方程与问题一完全一致
2.第一个房屋不取，初始化变成了[0, nums[1]]，这里置0是为了第三个房屋的计算，由于第一个强制放弃，所以输出最后一个房间的最优状态也就是res[-1]
最后返回这两种情况的最大值，就是全局最优。
```
代码如下：
```
def rob(self, nums):
    if len(nums) == 1:
        return nums[0]
    if len(nums) == 0:
        return 0
    if len(nums) == 2:
        return max(nums[0], nums[1])
    yes = [nums[0], nums[0]]
    no = [0, nums[1]]
    max_yes = 0
    max_no = 0
    for i in range(2, len(nums)):
        temp = no[i - 2] + nums[i]
        no.append(max(temp, no[i - 1]))
        temp = yes[i - 2] + nums[i]
        yes.append(max(temp, yes[i - 1]))
    max_no = no[-1]
    max_yes = yes[-2]
    return max(max_no, max_yes)
```
##打家劫舍III
在上次打劫完一条街道之后和一圈房屋后，小偷又发现了一个新的可行窃的地区。这个地区只有一个入口，我们称之为“根”。 除了“根”之外，每栋房子有且只有一个“父“房子与之相连。一番侦察之后，聪明的小偷意识到“这个地方的所有房屋的排列类似于一棵二叉树”。 如果两个直接相连的房子在同一天晚上被打劫，房屋将自动报警。

计算在不触动警报的情况下，小偷一晚能够盗取的最高金额。

####例子1:
```
输入: [3,2,3,null,3,null,1]

     3
    / \
   2   3
    \   \ 
     3   1

输出: 7 
解释: 小偷一晚能够盗取的最高金额 = 3 + 3 + 1 = 7.
```
####例子2:
```
输入: [3,4,5,1,3,null,1]

     3
    / \
   4   5
  / \   \ 
 1   3   1

输出: 9
解释: 小偷一晚能够盗取的最高金额 = 4 + 5 = 9.
```
这个问题最初想法是按照层次，求出每层的和，然后转移到第一个问题上求解，但是这种想法是错误的，不一定要一起取一层，只要保证父节点与左右子节点都不相邻即可，所以不能以层为单位转化问题。
按照条件给出转移方程：
```
f(root) = max(f(root) + f(ll) + f(lr) + f(rl) + f(rr), f(l) + f(r))
```
因此可以递归进行求解
```
def rob(self, root):
    if root is None:
        return 0
    temp1 = root.val
    temp2 = 0
    if root.left:
        temp1 += self.rob(root.left.left) + self.rob(root.left.right)
        temp2 += self.rob(root.left)
    if root.right:
        temp1 += self.rob(root.right.left) + self.rob(root.right.right)
        temp2 += self.rob(root.right)
    return max(temp1, temp2)
```
**结果虽然正确，但是时间复杂度太高，有很多重复性的计算，因此换一种想法，返回一个res保存两种情况：**
- res[0]表示不包括当前节点的最大值
- res[1]表示包括当前节点的最大值
因此转移方程：
```
res[0] = max(left[0], left[1]) + max(right[0], right[1])
res[1] = left[0] + right[0] + root.val
return max(res)
```
代码如下：
```
def rob(self, root):
    if root is None:
        return 0
    res = self.helper(root)
    return max(res)

def helper(self, root):
    res = [0, 0]
    if root is None:
        return res
    left = self.helper(root.left)
    right = self.helper(root.right)
    res[0] = max(left) + max(right)
    res[1] = left[0] + right[0] + root.val
    return res
```


## 总结：
这种按照同一个系列汇总问题的方式很有效，印象很深，以后做题也要分类去做。
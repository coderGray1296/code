# leetcode打家劫舍系列1-3

##打家劫舍I
你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。
给定一个代表每个房屋存放金额的非负整数数组，计算你在不触动警报装置的情况下，能够偷窃到的最高金额。
#### 例子1：
```
输入: [1,2,3,1]
输出: 4
解释: 偷窃 1 号房屋 (金额 = 1) ，然后偷窃 3 号房屋 (金额 = 3)。
偷窃到的最高金额 = 1 + 3 = 4 。
```

#### 例子2：
```
输入: [2,7,9,3,1]
输出: 12
解释: 偷窃 1 号房屋 (金额 = 2), 偷窃 3 号房屋 (金额 = 9)，接着偷窃 5 号房屋 (金额 = 1)。
偷窃到的最高金额 = 2 + 9 + 1 = 12 。
```
这是一道比较典型的动态规划DP寻找最优解的问题。DP问题的关键就是找到状态转移方程，下面我们从简单到复杂，把问题进行拆分进行分析，摸索状态方程：
```
1、当只有1间房的时候，我们没有选择，只能选择抢劫这间房；

2、当有两间房的时候，我们可以比较哪间房里面的钱多，抢劫钱多的房间就好了；

3、当有三间房的时候，有两种方案，抢1，3号房间/抢2号房间的，比较一下哪种方案多；

4、当有四间房的时候，因为我们已经知道了1，2，3间房时能获取到的最大金额，所以我们只需要将抢第四间房的金额数加上抢第二间房能获取到的最大金额数来和第三间房进行比较，取最大值就好了。
由此可以推出状态转移方程
```
**当我们抢劫第i家房间的时候，我们只需要将当前房间的金额于第i-2家房间所能获得的最大金额相加，然后在于第i-1家房间所能获得的最大金额进行比较，取最大的就好**
也就是：
```
用一个result列表来维护i个房间的i个状态，表示当前房间所能获得最大的金额
result[i] = max(result[i-2] + input[i], result[i-1])
只需要这样进行迭代，然后返回result数组的最后一个值就好。
```
为了降低空间复杂度，我们由于我们只需要result[i-1]和result[i-2]来计算，因此只维护两个变量first和second分别代表result[i-2]和result[i-1]。代码如下：
```
def rob(self, l):
    if len(l) == 0:
        return 0
    if len(l) == 1:
        return l[0]
    first = l[0]
    second = max(l[0], l[1])
    for i in range(2, len(l)):
        temp = first + l[i]
        first = second
        if temp > second:
            second = temp
    return second
```


## 总结：
考虑到元素重复时，初始的代码逻辑会有相应变化。